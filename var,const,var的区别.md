# var和let的区别
    var：当通过var创建一个变量的时候，会进行预解析（变量提升）
         因为var会预解析，所以变量会当作属性存到全局活动变量下（window下）
         不支持块级作用域
         不会主动把每次循环的值存储起来

    let: 当通过let创建一个变量的时候，不会进行预解析（不会变量提升）不会在        window下挂属性；
         在定义变量之前，访问变量,之前访问的空间，叫暂存死区
         支持块级作用域
         会把每次循环的值存储起来
         不能声明同名的变量

         块：{} 在块中套块，子块有函数，如果在父块或者父块的上方访问这个函数，那么都是undefined
                如果在子块的下方访问这个函数，就能找到这个函数
    const：常量（不可变的量）
        当声明一个变量，不允许改变的时候就使用const定义
        不能声明同名的变量，
        const赋值的数据，它只会监控这个数据的地址
# 面向对象
    - 单例模式：
        单例：单独的实例（一个对象）
        实例：描述具体的是一个事务         （你真胖）具体
        构造函数：抽象一个类的封装过程   （老师）

        原始值：字符串，数字，布尔值。。。
    - 高级单例模式（匿名函数返回对象的一种写法）
        让当前这个实例功能更加强大，还可以隐藏或者暴露细节信息
        1、为什么要用高级单例模式？
            让当前这个实例功能更加强大，还可以隐藏或者暴露内部细节信息

            解决了匿名冲突的问题
        2、高级函数如何写？
            （function(){
                return{

                }
            })()最后写一个变量接收这个功能强大的对象
            解决匿名冲突的问题：
                1、封闭空间（把变量或者函数放到函数中）
                        let a = 10
                    （function(){
                        let a = 20
            })()
                2、命名空间
